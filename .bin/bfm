#!/usr/bin/env bash

short() {
   previous_dir="$PWD"
   case "${1: -1}" in
      /) open "/" ;;
      a) open "$HOME/.apps" ;;
      h) open "$HOME/Hentet" ;;
      b) open "$HOME/.bin" ;;
      S) open "$HOME/.Scripts" ;;
      p) open "$HOME/Projekter" ;;
      d) open "$HOME/.dotfiles" ;;
      D) open "$HOME/Dokumenter" ;;
      c) open "$HOME/.config" ;;
      l) open "$HOME/.local" ;;
      w) open "$HOME/Billeder/wallpapers" ;;
      t) open "$HOME/.cache/fff/trash" ;;
      y) open "$HOME/Movies/youtube" ;;

      g) ((scroll != 0)) && ((scroll=0)) ;;
   esac
   redraw
}

key() {
   case "$1" in
      l|"") open "${list[scroll]}" ;;

      h) ((search == 1 && search_end_early != 1)) && open "$PWD"
	 [[ $PWD && $PWD != / ]] && { find_previous=1; open "${PWD%/*}"; } ;;
      j) ((scroll < list_total)) && {
	    ((scroll++)); ((y < max_items )) && ((y++))
	    print_line "$((scroll-1))"
	    printf '\n'
	    print_line "$scroll"
	    status_line; } ;;
      k) ((scroll > 0)) && {
	    ((scroll--))
	    print_line "$((scroll+1))"
	    ((y < 2)) && printf '\e[1L' || printf '\e[A' || ((y--))
	    print_line "$scroll"
	    status_line; } ;;
      g) read -rsn 1; short "$REPLY" ;;
      G) ((scroll != list_total)) && ((scroll=list_total)) && redraw ;;
      O) xdg-open "${list[scroll]}" 2>/dev/null & disown ;;
      R) [[ -x "${list[scroll]}" ]] && {
	    reset_terminal
      	    "${list[scroll]}"
      	    read &>/dev/null
      	    redraw full; } ;;
      .) shopt_flags=(u s)
	 shopt -"${shopt_flags[((a=a>0?0:++a))]}" dotglob
      	 redraw full ;;
      /) cmd_line "/" "search"
	 if [[ -z ${list[*]} || -z $cmd_reply ]]; then
	    list=("${cur_list[@]}")
      	    ((list_total=${#list[@]}-1))
      	    redraw
      	    search=
      	 else
	    search=1
      	 fi ;;
      S) reset_terminal; cd "$PWD" && "$SHELL"
	 setup_terminal; redraw ;;

      y|m|d|v) mark "$scroll" "$1" ;;

      p) [[ ${marked_files[*]} ]] && {
	    if [[ ! -w $PWD ]]; then
	       cmd_line "warn: no write access to dir."
      	    elif "${file_program[@]}" "${marked_files[@]}" .; then
	       redraw full
      	    else
	       cmd_line "warn: '${file_program[0]}' failed."
      	    fi
      	    marked_files=()
      	    redraw; } ;;
      V) cmd_line "new text file: "
	 [[ $cmd_reply ]] && {
	    reset_terminal
	    nvim "$cmd_reply"
	    redraw full; } ;;
      B) cmd_line "new bash script: "
	 [[ $cmd_reply ]] && {
	 [[ ! -f "$cmd_reply" ]] && { 
	    printf "#!/usr/bin/env bash\n\nmain(){\n<++>\n}\n\nmain \"\$@\"" >\
	    "$cmd_reply"; chmod a+x "$cmd_reply"; }
      	 reset_terminal; nvim "$cmd_reply"; redraw full; } ;;
      F) [[ -f ${list[scroll]} ]] && {
	    reset_terminal; setup_terminal
	    chwal -f "${list[scroll]##*/}"; redraw full; } ;;
      r) cmd_line "rename ${list[scroll]##*/}: "
	 [[ $cmd_reply ]] &&
	    if [[ -e $cmd_reply ]]; then
	       cmd_line "warn: '$cmd_reply' already exists."
	    elif [[ -w ${list[scroll]} ]]; then
	       mv "${list[scroll]}" "${PWD}/${cmd_reply}"
	       redraw full
	    else
	       cmd_line "warn: no write access to file."
	    fi ;;
      C) cmd_line "\"castnow ${list[scroll]##*/}\" add arguments? [y/n]: " y n
	 [[ $cmd_reply = y ]] &&
	    cmd_line "castnow ${list[scroll]##*/} "
	    cmd_line "\"castnow ${list[scroll]##*/} $cmd_reply\" ready to cast? [y/n]" y n
	    [[ $cmd_reply != y ]] &&
	       return
	    reset_terminal
	    castnow ${list[scroll]##*/} $cmd_reply
	    redraw full ;;
      n) cmd_line "mkdir: " "dirs"
         [[ $cmd_reply ]] &&
	    if [[ -e $cmd_reply ]]; then
	       cmd_line "warn: '$cmd_reply' already exists."
	    elif [[ -w $PWD ]]; then
	       mkdir -p "${PWD}/${cmd_reply}"
	       redraw full
	    else
	       cmd_line "warn: no write access to dir."
	    fi ;;
      f) cmd_line "mkfile: "
      [[ $cmd_reply ]] &&
      if [[ -e $cmd_reply ]]; then
      cmd_line "warn: '$cmd_reply' already exists."
      elif [[ -w $PWD ]]; then
      : > "${PWD}/${cmd_reply}"
      redraw full
      else
      cmd_line "warn: no write access to dir."
      fi ;;
      x) clear_screen; stat "${list[scroll]}"; read -rn 1; redraw ;;
      c) read -rsn 1
	 case $REPLY in
	    d) cmd_line "go to dir: " "dirs"
	    pushd "$PWD" &>/dev/null ||:
	    [[ $cmd_reply ]] && pushd "${cmd_reply/\~/$HOME}" &>/dev/null && open "$PWD" ;;
	    c) marked_files=(); redraw full
	 esac ;;
      q) : "${FFF_CD_FILE:=${XDG_CACHE_HOME:=${HOME}/.cache}/fff/.fff_d}"
      printf '%s\n' "$PWD" > "$FFF_CD_FILE"; exit
   esac
}

mark() {
   [[ $PWD != "$mark_dir" ]] && marked_files=()

   if [[ ${marked_files[$1]} == "${list[$1]}" ]]; then
      unset 'marked_files[scroll]'
   else
      marked_files[$1]="${list[$1]}"
      mark_dir="$PWD"
   fi

   printf '\e[K'; print_line "$1"

   case "$2" in
      y) file_program=(cp -R) ;;
      m) file_program=(mv) ;;
      d) file_program=(trash) ;;
      v) file_program=(nvim)
   esac

   key "j"; status_line
}

trash() {
   cmd_line "trash [${#marked_files[@]}] items? [y/n]: " y n
   [[ $cmd_reply != y ]] && return; cd "$FFF_TRASH" && "mv" "$@"; cd - &>/dev/null ||:

}

open() {
   [[ -d $1/ ]] && {
      search=""; search_end_early=""; previous_dir="$PWD"
      cd "${1:-/}" ||:; redraw full; }
   [[ -f $1 ]] && { mime_type="$(file "-${file_flags:-biL}" "$1")"
   case "$mime_type" in
      text/*|*x-empty*|*json*)
      reset_terminal; "${EDITOR:-vi}" "$1"; setup_terminal; redraw ;;
      *) nohup "${FFF_OPENER:-${opener:-xdg-open}}" "$1" &>/dev/null & disown ;;
   esac; }
}

cmd_line() {
   cmd_reply=
   printf '\e7\e[?6l\e[%sH\e[?25h' "$LINES"
   
   while IFS= read -rsn 1 -p $'\r\e[K'"${1}${cmd_reply}" read_reply; do
   case "$read_reply" in
      $'\177'|$'\b') cmd_reply="${cmd_reply%?}"; unset comp c ;;
      
      $'\t') comp_glob="$cmd_reply*"
      
      [[ $2 == dirs ]] &&
	 comp_glob="$cmd_reply*/"
      
      [[ -z ${comp[0]} ]] &&
	 IFS=$'\n' read -d "" -ra comp < <(compgen -G "$comp_glob")
      
      [[ -n ${comp[c]} ]] && {
	 cmd_reply="${comp[c]}"
	 ((c=c >= ${#comp[@]}-1 ? 0 : ++c))
      }
      ;;
   
      $'\e'|"${3:-null}")
      cmd_reply=
      break
      ;;
   
      "")
      [[ $2 == search && -d ${list[0]} ]] && ((list_total == 0)) && {
	 printf '\e[?25l\e[?6h'
	 open "${list[0]}"
	 search_end_early=1
   
	 unset comp c
	 return
      }
      break
      ;;
   
      "${2:-null}") cmd_reply="$read_reply"; break ;;
   
      "~") cmd_reply+="$HOME" ;;
      " "|*) cmd_reply+="$read_reply"; unset comp c ;;
   esac

   [[ $2 == search ]] && {
      printf '\e[?25l\e[?6h'
      list=("$PWD"/*"$cmd_reply"*)
      ((list_total=${#list[@]}-1,scroll=0))
      redraw
      printf '\e[?6l\e[%sH\e[?25h' "$LINES"
   }
   done

   unset comp c
   printf '\e[2K\e[?6h\e[?25l\e8'
}

status_line() {
   local mark_ui="[${#marked_files[@]}] selected (${file_program[*]}) [p] ->"

   PWD_escaped="${PWD//[^[:print:]]/^[}"

   printf '\e7\e[?6l\e[%sH\e[30;4%sm%*s\r%s %s%s\e[m\n\e[K\e[?6h\e8' \
      "$((LINES-1))" "${FFF_COL2:-1}" "$COLUMNS" "" "($((scroll+1))/$((list_total+1)))" \
      "${marked_files[*]:+${mark_ui}}" "${PWD_escaped:-/}"
}

read_dir() {
   local dirs=(); local files=(); local item_index
   
   # If '$PWD' is '/', unset it to avoid '//'.
   [[ $PWD == / ]] && PWD=
   
   for item in "$PWD"/*; do
      if [[ -d $item ]]; then
	 dirs+=("$item")
      	 ((item_index++))
      	 
      	 [[ $item == "$previous_dir" ]] &&
      	 ((previous_index=item_index))
      else
	 files+=("$item")
      fi
   done
   
   list=("${dirs[@]}" "${files[@]}")
   
   [[ -z ${list[0]} ]] && list[0]="empty"
   
   ((list_total=${#list[@]}-1))
   
   cur_list=("${list[@]}")
}

print_line() {
   local file_name="${list[$1]##*/}"
   local file_ext="${file_name##*.}"
   local format; local suffix
   
   format+="\\e[${fi:-37}m"
   [[ -z ${list[$1]} ]] && return
   [[ -d ${list[$1]} ]] && {
      format+="\\e[${di:-1;3${FFF_COL1:-2}}m"
      suffix+='/'; }
   [[ -b ${list[$1]} ]] && format+="\\e[${bd:-40;33;01}m"
   [[ -c ${list[$1]} ]] && format+="\\e[${cd:-40;33;01}m"
   [[ -x ${list[$1]} ]] && format+="\\e[${ex:-01;32}m"
   [[ -h ${list[$1]} && ! -e ${list[$1]} ]] && format+="\\e[${mi:-01;31;7}m"
   [[ -h ${list[$1]} ]] && format+="\\e[${ln:-01;36}m"
   [[ -p ${list[$1]} ]] && format+="\\e[${pi:-40;33}m"
   [[ -S ${list[$1]} ]] && format+="\\e[${so:-01;35}m"

   (($1 == scroll)) && format+="\\e[1;3${FFF_COL4:-6};7m"
   
   [[ ${marked_files[$1]} == "${list[$1]:-null}" ]] && {
      format+="\\e[3${FFF_COL3:-1}m "
      suffix+='*'; }

   file_name="${file_name//[^[:print:]]/^[}"

   printf '\r%b%s\e[m\r' "$format" "${file_name}${suffix}"
}

draw_dir() {
   local scroll_start="$scroll"; local scroll_new_pos; local scroll_end

   ((find_previous == 1)) && {
      ((scroll_start=previous_index-1))
      ((scroll=scroll_start))
      find_previous=
   }

   if ((list_total < max_items || scroll < max_items/2)); then
      ((scroll_start=0))
      ((scroll_end=max_items))
      ((scroll_new_pos=scroll + 1))

   elif ((list_total - scroll < max_items/2)); then
      ((scroll_start=list_total - max_items + 1))
      ((scroll_new_pos=max_items - (list_total-scroll)))
      ((scroll_end=list_total+1))

   else
      ((scroll_start=scroll-max_items/2))
      ((scroll_end=scroll_start+max_items))
      ((scroll_new_pos=max_items/2+1))
   fi

   for ((i=scroll_start;i<scroll_end;i++)); {
      ((i > scroll_start)) && printf '\n'
      print_line "$i"; }

   printf '\e[%sH' "$scroll_new_pos"
   ((y=scroll_new_pos))
}

redraw() {
   [[ $1 == full ]] && { read_dir; scroll=0; }
   clear_screen; draw_dir; status_line
}

clear_screen() { printf '\e[%sH\e[9999C\e[1J%b\e[1;%sr' "$((LINES-2))" "${TMUX:+\e[2J}" "$max_items"; }

setup_terminal() { printf '\e[?1049h\e[?6h\e[?7l\e[?25l\e[2J\e[1;%sr' "$max_items"; }

get_term_size() { read -r LINES COLUMNS < <(stty size); ((max_items=LINES-3)); }

reset_terminal() { printf '\e[?6l\e[?7h\e[?25h\e[2J\e[;r'; }

main() {
   pushd "$1" &>/dev/null ||:

   ((BASH_VERSINFO[0] > 3)) &&
      read_flags=(-t 0.05)

   get_term_size
   setup_terminal
   shopt -s nocaseglob nullglob
   mkdir -p "${FFF_TRASH:=${XDG_CACHE_HOME:=${HOME}/.cache}/fff/trash}"
   trap 'reset_terminal; printf "\e[?1049l"' EXIT
   trap 'key q' INT
   trap 'sleep .1 && get_term_size && redraw' WINCH

   redraw full

   for ((;;)); { read "${read_flags[@]}" -srn 1 && key "$REPLY";}
   }

main "$@"
